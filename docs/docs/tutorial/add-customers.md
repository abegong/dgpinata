# Add customers

At this point, we have a lemonade stand that sells three products. Let's add some customers to the mix. We'll give them a first name, last name, and a unique ID. We'll also give them a `created_at` field, which will be the timestamp at which they were created.

As before, we start by importing the necessary modules. This time around, we're going to include the `faker` module, which will help us generate random names for our customers.

```python
from faker import Faker
import random
from typing import Dict
from uuid import uuid4
from pydantic import Field

import dgpinata as dgp
```

`faker` is a library that generates fake data. We'll use it to generate random first and last names for our customers. To do that, we'll create an instance of the `Faker` class.

```python
faker = Faker()
```

Next, let's define the `Customer` class. We'll give it three fields: `customer_id`, `first_name`, and `last_name`. We'll also give it a `created_at` field, which will be the timestamp at which the customer was created.

Beyond these fields, we're going to change how we emit events. Instead of `Sales` being generated spontaneously by the `Stand`, we're going to have them be generated by the customers.

We'll create an emitter called `new_sale` that will emit a `Sale` event. This emitter will have a 10% chance of emitting a sale event every time it's called. The `customer_id` field will be set to the customer's ID, the `product_id` field will be set to a random product ID, the `amount` field will be set to 1, and the `timestamp` field will be set to the current timestamp.

Last, we'll give the `Customer` class a `default_values` attribute. This attribute will be a list of dictionaries, each of which will contain a set of default values for the `Customer` class. In this case, we're going to give the `Customer` class a single default value: a customer named Alfred Adams, created at timestamp 0. This is convenient, because it lets us avoid the edge case where we have no customers at the start of the simulation.

```python
class Customer(dgp.Entity):
    customer_id: str = Field(default_factory=lambda: str(uuid4()))
    first_name: str = Field(default_factory=faker.first_name)
    last_name: str = Field(default_factory=faker.last_name)
    created_at: int

    emitters : Dict = {
        "new_sale" : dgp.IntervalEmitter.from_params(
            event_type_name="Sale",
            skip_probability=0.90,
            customer_id = "parent.customer_id",
            product_id = dgp.RandomObjectAttributeChooser(
                object_eval_str='sim.entities["Product"]',
                attribute="product_id"
            ),
            amount = 1,
            timestamp = "timestamp",
        )
    }

    default_values = [
        {"first_name": "Alfred", "last_name": "Adams", "created_at": 0}
    ]
```

Next, let's update our `Sale` event type to include a `customer_id` field. This field will be a reference to the `customer_id` of the customer who made the purchase.

```python
class Sale(dgp.Event):
    sale_id: str = Field(default_factory=lambda: str(uuid4()))
    customer_id: str
    product_id: str
    amount: int
    timestamp: int
```

<!--
```python
class Product(dgp.Entity):
    product_id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    price: float

    default_values = [
        {"name": "Lemonade", "price": 2.50},
        {"name": "Iced Tea", "price": 3.75},
        {"name": "Water", "price": 0.50},
    ]
```
-->

Finally, let's update our `Stand` entity type to include the `Customer` entity type. We'll also update the `new_customer` emitter to emit a new `Customer` at random 20% of the time.

```python
class Stand(dgp.Entity):

    emitters : Dict = {
        "new_customer" : dgp.IntervalEmitter.from_params(
            entity_type_name="Customer",
            skip_probability=0.8,
            created_at="timestamp",
        )        
    }
```

Now, let's update our `Simulation` class to include the `Customer` entity type, and run the simulation.

```python
sim = dgp.Simulation(
    event_types=[Sale],
    entity_types=[Stand, Customer, Product],
    rand_seed=42,
)
print(sim.run(steps=100))
```

You should see output like this:

```
=== Entities ===
  Stand: 1
  Customer: 22
  Product: 3

=== Events ===
  Sale: 103
```

This is a pretty big change: we didn't just add the concept of a `Customer`. We also changed the way that events are emitted.

Instead of `Stand` emitting `Sales` events, the `Stand` object itself emits `new_customer` events, and adds new `Customer` objects to the simulation. From there, each `Customer` can emit `new_sale` events, which create new `Sale` objects. This is a more realistic model of how sales work in the real world, where customers make purchases rather than stands selling products.

In the next section, we'll take advantage of this more realistic structure to give customers preferences across products.

<!--
```python
assert str(sim.get_report()) == """\
=== Entities ===
  Stand: 1
  Customer: 22
  Product: 3

=== Events ===
  Sale: 103
"""
```
-->